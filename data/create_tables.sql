-- Fichier de creation des tables en suivant notre MLD -- 

BEGIN; -- Déclare une transaction
-- Une transaction est un ensemble de commande destiné à être joué ensemble en coherence. 
-- Idée : si une des commandes fail ALORS le SGBD annule toutes les commandes déjà passées.

-- On s'assure que les tables n'existent pas déjà avant de les créer
DROP TABLE IF EXISTS "list", "card", "label", "card_has_label";


CREATE TABLE "list" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, 
  "name" TEXT NOT NULL,
  "position" INTEGER NOT NULL DEFAULT 0,
  "created_at" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" TIMESTAMPTZ
);

CREATE TABLE "card" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, 
  "content" TEXT NOT NULL DEFAULT '',
  "color" VARCHAR(7),
  "position" INTEGER NOT NULL DEFAULT 0,
  "list_id" INTEGER NOT NULL REFERENCES "list"("id") ON DELETE CASCADE,
  "created_at" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" TIMESTAMPTZ
);

CREATE TABLE "label" (
  "id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, 
  "name" TEXT UNIQUE,
  "color" VARCHAR(7),
  "created_at" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" TIMESTAMPTZ
);

CREATE TABLE "card_has_label" (
  "card_id" INTEGER NOT NULL REFERENCES "card"("id") ON DELETE CASCADE,
  "label_id" INTEGER NOT NULL REFERENCES "label"("id") ON DELETE CASCADE,
  "created_at" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  "updated_at" TIMESTAMPTZ,
  PRIMARY KEY ("card_id", "label_id")
);


COMMIT; -- Ferme une transaction

-- PRIMARY KEY = UNIQUE + NOT NULL. Il ne peut y avoir qu'une seule PRIMARY KEY dans une table.
-- UNIQUE  = assure l'unicité du champ. Exemple : il peut pas y avoir 2 labels avec le même name

-- GENERATED AS IDENTITY = la fonction choisie pour générer un nombre. => une fonction qui s'incrémente de 1 en 1
-- BY DEFAULT = par défaut, si on précise pas de valeur pour ce champ, le SGBD se charge de mettre une valeur
-- ALWAYS = on interdit à aux devs de choisir lui même les ID quand on fait le seeding. Problème, pas pratique pour du seeding.
-- Doc: https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-identity-column/

-- DEFAULT <VALUE> : au choix. Pour que le SGBD génère une valeur si l'utilisateur n'en met pas ET qu'on autorise ce comportement côté "business"


-- AJOUTER UNE CLEF ETRANGERE : 

-- 1. Soit au moment de la création de la table 
--    "list_id" INTEGER NOT NULL REFERENCES "list"("id")
-- 2. Soit, si la table est déjà créée : 
--    ALTER TABLE "card" ADD FOREIGN KEY ("list_id") REFERENCES "list"("id");

-- PRIMARY KEY ("card_id", "label_id") : clé primaire COMPOSITE. 
-- clé primaire doit être unique, donc impossible d'avoir deux fois le même couple carte/label dans la table !
-- Tout ça c'est pas obligatoire, c'est simplement pour votre culture. 
-- Perso (Enzo), j'aurai mis une contrainte d'unicité simple (UNIQUE) sur le couple, et j'aurais rajouté un ID.
-- On interdit d'avoir 2 fois le même label sur la même carte. Par contre, une carte peut avoir plusieurs labels differents


-- created_at : pour savoir quand l'enregistrement a été ajouté à la table. Ex : pour accéder à la date de création de la liste
-- updated_at l pour savoir quand l'enregistrement a été modifé. Ex: pour savoir la date de mise à jour d'une carte
-- Bonne pratique d'avoir toujours ces champs en BDD. Notamment pour comprendre l'historique de la BDD. 


-- CURRENT_TIMESTAMP = NOW() = l'heure actuelle

-- Quand on créer une clé étrangère, on peut rajouter des contraintes
-- Ex: "list_id" INTEGER NOT NULL REFERENCES "list"("id") ON DELETE CASCADE,
--     Si la liste est supprimé, je CASCADE, ie. je supprime toutes les cartes liées à la liste !
-- Si on ne rajoute pas le ON DELETE CASCADE : 
--     Alors il sera impossible de supprimer une liste qui contient des cartes !! Car la carte ne peut pas pointer vers une liste qui n'existe pas !
--     On aurait un message d'erreur de type : "integrity contrains violation"
-- Le mettre ou pas ??? => c'est un choix "business" = UX/UI

-- DROP TABLE = supprime la table (= la structure)
-- TRUNC TABLE = supprime tous les enregistrement de la table (= le contenu de la table)
